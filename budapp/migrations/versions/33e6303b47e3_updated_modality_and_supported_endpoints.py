"""Updated modality and supported endpoints

Revision ID: 33e6303b47e3
Revises: 006234a6eb89
Create Date: 2025-05-20 01:43:22.150811

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa
from alembic_postgresql_enum import ColumnType
from alembic_postgresql_enum import TableReference
from sqlalchemy.dialects import postgresql
from sqlalchemy import text

# revision identifiers, used by Alembic.
revision: str = '33e6303b47e3'
down_revision: Union[str, None] = '006234a6eb89'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    
    # 1. Add supported_endpoints column
    op.add_column('model', sa.Column('supported_endpoints', 
                 postgresql.ARRAY(postgresql.ENUM('/v1/chat/completions', '/v1/completions', 
                                                 '/v1/images/generations', '/v1/audio/transcriptions', 
                                                 '/v1/audio/speech', '/v1/embeddings', '/v1/batch', 
                                                 '/v1/responses', '/v1/rerank', '/v1/moderations', 
                                                 name='model_endpoint_enum', create_type=False)), 
                 nullable=True))
    
    # 2. Update supported_endpoints using Python
    connection = op.get_bind()
    
    # Get all models and their modalities
    models = connection.execute(text("SELECT id, modality FROM model")).fetchall()
    
    # Update each model with appropriate endpoints
    for model_id, modalities in models:
        # Convert modalities to strings for comparison
        modality_strings = [str(m) for m in modalities] if modalities else []
        
        # Determine endpoints based on modalities
        endpoints = []
        if 'llm' in modality_strings:
            endpoints = ['/v1/chat/completions', '/v1/completions']
        elif 'mllm' in modality_strings:
            endpoints = ['/v1/chat/completions']
        elif 'image' in modality_strings:
            endpoints = ['/v1/images/generations']
        elif 'embedding' in modality_strings:
            endpoints = ['/v1/embeddings']
        elif 'text_to_speech' in modality_strings:
            endpoints = ['/v1/audio/speech']
        elif 'speech_to_text' in modality_strings:
            endpoints = ['/v1/audio/transcriptions']
        elif 'llm_embedding' in modality_strings:
            endpoints = ['/v1/embeddings', '/v1/chat/completions']
        elif 'mllm_embedding' in modality_strings:
            endpoints = ['/v1/embeddings']
        else:
            endpoints = ['/v1/chat/completions']  # Default
        
        # Update the model
        endpoint_sql_array = ','.join(f"'{e}'" for e in endpoints)
        connection.execute(text(
            f"UPDATE model SET supported_endpoints = ARRAY[{endpoint_sql_array}]::model_endpoint_enum[] WHERE id = '{model_id}'"
        ))
    
    # 3. Make supported_endpoints non-nullable
    op.alter_column('model', 'supported_endpoints', nullable=False)
    
    # 4. Handle the enum transition manually using Python
    
    # 4.1 Create the new enum type
    op.execute(text("CREATE TYPE modality_enum_new AS ENUM ('text_input', 'text_output', 'image_input', 'image_output', 'audio_input', 'audio_output')"))
    
    # 4.2 Create temporary columns with the new type
    op.add_column('cloud_model', sa.Column('modality_new', postgresql.ARRAY(sa.Enum('text_input', 'text_output', 'image_input', 'image_output', 'audio_input', 'audio_output', name='modality_enum_new')), nullable=True))
    op.add_column('model', sa.Column('modality_new', postgresql.ARRAY(sa.Enum('text_input', 'text_output', 'image_input', 'image_output', 'audio_input', 'audio_output', name='modality_enum_new')), nullable=True))
    
    # 4.3 Update the temporary columns with mapped values using Python
    
    # For cloud_model
    cloud_models = connection.execute(text("SELECT id, modality FROM cloud_model")).fetchall()
    for model_id, modalities in cloud_models:
        modality_strings = [str(m) for m in modalities] if modalities else []
        new_modalities = []
        
        if 'llm' in modality_strings:
            new_modalities = ['text_input', 'text_output']
        elif 'mllm' in modality_strings:
            new_modalities = ['text_input', 'image_input', 'text_output']
        elif 'image' in modality_strings:
            new_modalities = ['text_input', 'image_output']
        elif 'embedding' in modality_strings:
            new_modalities = ['text_input']
        elif 'text_to_speech' in modality_strings:
            new_modalities = ['text_input', 'audio_output']
        elif 'speech_to_text' in modality_strings:
            new_modalities = ['audio_input', 'text_output']
        elif 'llm_embedding' in modality_strings:
            new_modalities = ['text_input']
        elif 'mllm_embedding' in modality_strings:
            new_modalities = ['text_input', 'image_input']
        else:
            new_modalities = ['text_input', 'text_output']
        
        modality_sql_array = ','.join(f"'{m}'" for m in new_modalities)
        connection.execute(text(
            f"UPDATE cloud_model SET modality_new = ARRAY[{modality_sql_array}]::modality_enum_new[] WHERE id = '{model_id}'"
        ))
    
    # For model
    models = connection.execute(text("SELECT id, modality FROM model")).fetchall()
    for model_id, modalities in models:
        modality_strings = [str(m) for m in modalities] if modalities else []
        new_modalities = []
        
        if 'llm' in modality_strings:
            new_modalities = ['text_input', 'text_output']
        elif 'mllm' in modality_strings:
            new_modalities = ['text_input', 'image_input', 'text_output']
        elif 'image' in modality_strings:
            new_modalities = ['text_input', 'image_output']
        elif 'embedding' in modality_strings:
            new_modalities = ['text_input']
        elif 'text_to_speech' in modality_strings:
            new_modalities = ['text_input', 'audio_output']
        elif 'speech_to_text' in modality_strings:
            new_modalities = ['audio_input', 'text_output']
        elif 'llm_embedding' in modality_strings:
            new_modalities = ['text_input']
        elif 'mllm_embedding' in modality_strings:
            new_modalities = ['text_input', 'image_input']
        else:
            new_modalities = ['text_input', 'text_output']
        
        modality_sql_array = ','.join(f"'{m}'" for m in new_modalities)
        connection.execute(text(
            f"UPDATE model SET modality_new = ARRAY[{modality_sql_array}]::modality_enum_new[] WHERE id = '{model_id}'"
        ))
    
    # 4.4 Drop the old columns and rename the new ones
    op.drop_column('cloud_model', 'modality')
    op.drop_column('model', 'modality')
    
    op.alter_column('cloud_model', 'modality_new', new_column_name='modality', nullable=False)
    op.alter_column('model', 'modality_new', new_column_name='modality', nullable=False)
    
    # 4.5 Drop the old enum type and rename the new one
    op.execute(text("DROP TYPE modality_enum"))
    op.execute(text("ALTER TYPE modality_enum_new RENAME TO modality_enum"))
    
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    
    # 1. Handle the enum transition manually for downgrade using Python
    connection = op.get_bind()
    
    # 1.1 Create the old enum type
    op.execute(text("CREATE TYPE modality_enum_old AS ENUM ('llm', 'mllm', 'image', 'embedding', 'text_to_speech', 'speech_to_text', 'llm_embedding', 'mllm_embedding')"))
    
    # 1.2 Create temporary columns with the old type
    op.add_column('cloud_model', sa.Column('modality_old', postgresql.ARRAY(sa.Enum('llm', 'mllm', 'image', 'embedding', 'text_to_speech', 'speech_to_text', 'llm_embedding', 'mllm_embedding', name='modality_enum_old')), nullable=True))
    op.add_column('model', sa.Column('modality_old', postgresql.ARRAY(sa.Enum('llm', 'mllm', 'image', 'embedding', 'text_to_speech', 'speech_to_text', 'llm_embedding', 'mllm_embedding', name='modality_enum_old')), nullable=True))
    
    # 1.3 Update the temporary columns with mapped values (reverse mapping) using Python
    
    # For cloud_model
    cloud_models = connection.execute(text("SELECT id, modality FROM cloud_model")).fetchall()
    for model_id, modalities in cloud_models:
        modality_strings = [str(m) for m in modalities] if modalities else []
        old_modalities = []
        
        if 'text_input' in modality_strings and 'text_output' in modality_strings and len(modality_strings) == 2:
            old_modalities = ['llm']
        elif 'text_input' in modality_strings and 'image_input' in modality_strings and 'text_output' in modality_strings:
            old_modalities = ['mllm']
        elif 'text_input' in modality_strings and 'image_output' in modality_strings:
            old_modalities = ['image']
        elif 'text_input' in modality_strings and len(modality_strings) == 1:
            old_modalities = ['embedding']
        elif 'text_input' in modality_strings and 'audio_output' in modality_strings:
            old_modalities = ['text_to_speech']
        elif 'audio_input' in modality_strings and 'text_output' in modality_strings:
            old_modalities = ['speech_to_text']
        elif 'text_input' in modality_strings and 'image_input' in modality_strings and len(modality_strings) == 2:
            old_modalities = ['mllm_embedding']
        else:
            old_modalities = ['llm']
        
        modality_sql_array = ','.join(f"'{m}'" for m in old_modalities)
        connection.execute(text(
            f"UPDATE cloud_model SET modality_old = ARRAY[{modality_sql_array}]::modality_enum_old[] WHERE id = '{model_id}'"
        ))
    
    # For model
    models = connection.execute(text("SELECT id, modality FROM model")).fetchall()
    for model_id, modalities in models:
        modality_strings = [str(m) for m in modalities] if modalities else []
        old_modalities = []
        
        if 'text_input' in modality_strings and 'text_output' in modality_strings and len(modality_strings) == 2:
            old_modalities = ['llm']
        elif 'text_input' in modality_strings and 'image_input' in modality_strings and 'text_output' in modality_strings:
            old_modalities = ['mllm']
        elif 'text_input' in modality_strings and 'image_output' in modality_strings:
            old_modalities = ['image']
        elif 'text_input' in modality_strings and len(modality_strings) == 1:
            old_modalities = ['embedding']
        elif 'text_input' in modality_strings and 'audio_output' in modality_strings:
            old_modalities = ['text_to_speech']
        elif 'audio_input' in modality_strings and 'text_output' in modality_strings:
            old_modalities = ['speech_to_text']
        elif 'text_input' in modality_strings and 'image_input' in modality_strings and len(modality_strings) == 2:
            old_modalities = ['mllm_embedding']
        else:
            old_modalities = ['llm']
        
        modality_sql_array = ','.join(f"'{m}'" for m in old_modalities)
        connection.execute(text(
            f"UPDATE model SET modality_old = ARRAY[{modality_sql_array}]::modality_enum_old[] WHERE id = '{model_id}'"
        ))
    
    # 1.4 Drop the old columns and rename the new ones
    op.drop_column('cloud_model', 'modality')
    op.drop_column('model', 'modality')
    
    op.alter_column('cloud_model', 'modality_old', new_column_name='modality', nullable=False)
    op.alter_column('model', 'modality_old', new_column_name='modality', nullable=False)
    
    # 1.5 Drop the new enum type and rename the old one
    op.execute(text("DROP TYPE modality_enum"))
    op.execute(text("ALTER TYPE modality_enum_old RENAME TO modality_enum"))
    
    # 2. Drop the supported_endpoints column
    op.drop_column('model', 'supported_endpoints')
    
    # ### end Alembic commands ###